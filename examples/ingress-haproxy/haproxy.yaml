apiVersion: v1
kind: ServiceAccount
metadata:
  name: neo4j-haproxy
  namespace: neo4j
  labels:
    helm.sh/chart: haproxy-1.17.3
    app.kubernetes.io/name: haproxy
    app.kubernetes.io/instance: neo4j-haproxy
    app.kubernetes.io/version: "2.6.6"
    app.kubernetes.io/managed-by: Helm
---
# Source: haproxy/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: neo4j-haproxy
  namespace: neo4j
  labels:
    helm.sh/chart: haproxy-1.17.3
    app.kubernetes.io/name: haproxy
    app.kubernetes.io/instance: neo4j-haproxy
    app.kubernetes.io/version: "2.6.6"
    app.kubernetes.io/managed-by: Helm
data:
  haproxy.cfg: |
    global
        log stdout format raw local0
        lua-prepend-path /usr/local/etc/haproxy/?.lua
        lua-load /usr/local/etc/haproxy/discovery.lua
    
    defaults
        log	global
        timeout	connect	5000
        timeout	client	50000
        timeout	server	50000
        timeout	tunnel	1200000
    
    frontend generic-in
        bind *:8080
        tcp-request inspect-delay 20s
        acl content_present req_len gt 0
        tcp-request content accept if content_present
        use_backend neo4j-bolt if !HTTP
        use_backend neo4j-bolt if { hdr(upgrade) -i -m str "websocket" }
        use_backend neo4j-discovery if { hdr(accept) -i -m str "application/json" }
        default_backend neo4j-http
    
    backend neo4j-http
        mode http
        option httpchk
        option forwardfor
        server neo4j-browser "${NEO4J_HTTP}" check maxconn 128
    
    backend neo4j-bolt
        mode tcp
        option tcp-check
        server neo4j-bolt "${NEO4J_BOLT}" check maxconn 2048
    backend neo4j-discovery
        mode http
        http-request use-service lua.neo4j_discovery
    

  discovery.lua: |
    local http = require('http')
    local json = require('json')
    
    local function neo4j_discovery(applet)
        local req = http.request.parse(applet)

        local req_host = req:get_header("host")
        if not req_host then
            core.Alert("request doesn't have host header!?")
            return
        end
        for k, v in req:get_headers() do
            core.Debug(k .. ": " .. v)
        end
        local req_host_port = ""
        -- because the js driver will provide a default port if we don't!
        if req:get_header("x-scheme") == "http" and req:get_header("x-forwarded-port") == "80" then
            req_host_and_port = req_host .. ":80"
        elseif req:get_header("x-scheme") == "https" and req:get_header("x-forwarded-port") == "443" then
            req_host_and_port = req_host .. ":443"
        elseif req_host:find(":", 1, true) ~= nil then
            req_host_and_port = req_host
        end
        core.Info(string.format("translating discovery request with req_host_and_port : %s", req_host_and_port))
        
        -- look for a particular backend named "neo4j-http"
        local http_backend = core.backends["neo4j-http"]
        if not http_backend then
            core.Alert("cannot find backend named 'neo4j-http'")
            return
        end
        
        -- get the first server in our backend
        local server = nil
        for k, v in pairs(http_backend.servers) do
            server = v
            break
        end
        local host = server:get_addr()
        if not host then
            core.Alert(string.format("can't get a host value for server %s", server))
            return
        end
        local res, err = http.get { url = string.format("http://%s", host),
                                    headers = { host = host,
                                                ["accept"] = { "application/json" },
                                                ["connection"] = { "close" } }
        }
        if res then
            for k, v in res:get_headers() do
                core.Debug(k .. ": " .. v)
            end
        else
            core.Debug(err)
        end
        local response_body = json.decode(res.content)
        local proxy_response = {}
        local ip_address_match, _ = string.gmatch(host, '([^:]+)', 2)
        local ip = ip_address_match()
        local port = ip_address_match()
        print(ip)
        print(port)
        local req_port = req:get_header("x-forwarded-port")
        for index, value in pairs(response_body) do
            if not (index == "auth_config") then
                proxy_response[index] = string.gsub(value, ip, req_host)
                proxy_response[index] = string.gsub(proxy_response[index], "7474", req_port)
                proxy_response[index] = string.gsub(proxy_response[index], "7687", req_port)
                core.Info(proxy_response[index])
                core.Info(req_host)
                core.Info(req_port)
            end
        end
        http.response.create {
            status_code = 200,
            content = json.encode(proxy_response),
            headers = { host = host,
                        ["accept"] = { "application/json" } } }:send(applet)
    
    
    end

    core.register_service('neo4j_discovery', 'http', neo4j_discovery)
---
# Source: haproxy/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: neo4j-haproxy
  namespace: neo4j
  labels:
    helm.sh/chart: haproxy-1.17.3
    app.kubernetes.io/name: haproxy
    app.kubernetes.io/instance: neo4j-haproxy
    app.kubernetes.io/version: "2.6.6"
    app.kubernetes.io/managed-by: Helm
spec:
  type: LoadBalancer
  selector:
    app.kubernetes.io/name: haproxy
    app.kubernetes.io/instance: neo4j-haproxy
  ports:
    - name: http
      protocol: TCP
      port: 8080
      targetPort: http
    - name: https
      protocol: TCP
      port: 8443
      targetPort: https
    - name: stat
      protocol: TCP
      port: 1024
      targetPort: stat
---
# Source: haproxy/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: neo4j-haproxy
  namespace: neo4j
  labels:
    helm.sh/chart: haproxy-1.17.3
    app.kubernetes.io/name: haproxy
    app.kubernetes.io/instance: neo4j-haproxy
    app.kubernetes.io/version: "2.6.6"
    app.kubernetes.io/managed-by: Helm
spec:
  minReadySeconds: 0
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: haproxy
      app.kubernetes.io/instance: neo4j-haproxy
  template:
    metadata:
      labels:
        app.kubernetes.io/name: haproxy
        app.kubernetes.io/instance: neo4j-haproxy
    spec:
      serviceAccountName: neo4j-haproxy
      terminationGracePeriodSeconds: 60
      dnsPolicy: ClusterFirst
      volumes:
        - name: haproxy-config
          configMap:
            name: neo4j-haproxy
        - name: haproxy-lua-lib
          configMap:
            name: haproxy-lua-lib
      containers:
        - name: haproxy
          image: "haproxytech/haproxy-ubuntu:2.9"
          imagePullPolicy: IfNotPresent
          args:
            - -f
            - /usr/local/etc/haproxy/haproxy.cfg
          env:
            - name: NEO4J_HTTP
              value: "ingress-haproxy-lb-neo4j:7474/browser"
            - name: NEO4J_BOLT
              value: "ingress-haproxy-lb-neo4j:7687"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: https
              containerPort: 8443
              protocol: TCP
            - name: stat
              containerPort: 1024
              protocol: TCP
          resources:
            requests:
              cpu: 250m
              memory: 128Mi
          volumeMounts:
            - name: haproxy-config
              mountPath: /usr/local/etc/haproxy/haproxy.cfg
              subPath: haproxy.cfg
            - name: haproxy-config
              mountPath: /usr/local/etc/haproxy/discovery.lua
              subPath: discovery.lua
            - name: haproxy-lua-lib
              mountPath: /usr/local/etc/haproxy/http.lua
              subPath: http.lua
            - name: haproxy-lua-lib
              mountPath: /usr/local/etc/haproxy/json.lua
              subPath: json.lua
